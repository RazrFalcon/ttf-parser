// This file is autogenerated by scripts/gen-tables.py
// Do not edit it!

// All structs in this module use fixed-size arrays,
// so Rust compiler will check bounds at compile time.

#![allow(dead_code)]

use crate::parser::{FromData, Offset32};
use crate::Tag;

#[derive(Clone, Copy)]
pub struct TableRecord {
    data: [u8; 16],
}

impl TableRecord {
    pub const SIZE: usize = 16;

    #[inline(always)]
    pub fn new(input: &[u8]) -> Option<Self> {
        use core::convert::TryInto;
        input.try_into().ok().map(|data| TableRecord { data })
    }

    #[inline(always)]
    pub fn table_tag(&self) -> Tag {
        Tag(u32::from_be_bytes([
            self.data[0],
            self.data[1],
            self.data[2],
            self.data[3],
        ]))
    }

    #[inline(always)]
    pub fn check_sum(&self) -> u32 {
        u32::from_be_bytes([self.data[4], self.data[5], self.data[6], self.data[7]])
    }

    #[inline(always)]
    pub fn offset(&self) -> Offset32 {
        Offset32(u32::from_be_bytes([
            self.data[8],
            self.data[9],
            self.data[10],
            self.data[11],
        ]))
    }

    #[inline(always)]
    pub fn length(&self) -> u32 {
        u32::from_be_bytes([self.data[12], self.data[13], self.data[14], self.data[15]])
    }
}

impl FromData for TableRecord {
    const SIZE: usize = TableRecord::SIZE;

    #[inline]
    fn parse(data: &[u8]) -> Option<Self> {
        Self::new(data)
    }
}

pub mod head {
    pub const TABLE_SIZE: usize = 54;
    pub const UNITS_PER_EM_OFFSET: usize = 18;
    pub const INDEX_TO_LOC_FORMAT_OFFSET: usize = 50;
}

pub mod hhea {
    pub const TABLE_SIZE: usize = 36;
    pub const ASCENDER_OFFSET: usize = 4;
    pub const DESCENDER_OFFSET: usize = 6;
    pub const LINE_GAP_OFFSET: usize = 8;
    pub const NUMBER_OF_H_METRICS_OFFSET: usize = 34;
}

pub mod hmtx {
    use crate::parser::FromData;

    #[derive(Clone, Copy)]
    pub struct HorizontalMetrics {
        data: [u8; 4],
    }

    impl HorizontalMetrics {
        pub const SIZE: usize = 4;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| HorizontalMetrics { data })
        }

        #[inline(always)]
        pub fn advance_width(&self) -> u16 {
            u16::from_be_bytes([self.data[0], self.data[1]])
        }

        #[inline(always)]
        pub fn lsb(&self) -> i16 {
            i16::from_be_bytes([self.data[2], self.data[3]])
        }
    }

    impl FromData for HorizontalMetrics {
        const SIZE: usize = HorizontalMetrics::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod vhea {
    pub const TABLE_SIZE: usize = 36;
    pub const ASCENDER_OFFSET: usize = 4;
    pub const DESCENDER_OFFSET: usize = 6;
    pub const LINE_GAP_OFFSET: usize = 8;
    pub const NUM_OF_LONG_VER_METRICS_OFFSET: usize = 34;
}

pub mod post {
    pub const TABLE_SIZE: usize = 32;
    pub const UNDERLINE_POSITION_OFFSET: usize = 8;
    pub const UNDERLINE_THICKNESS_OFFSET: usize = 10;
}

pub mod cmap {
    use crate::parser::{FromData, Offset32};
    use crate::GlyphId;

    #[derive(Clone, Copy)]
    pub struct EncodingRecord {
        data: [u8; 8],
    }

    impl EncodingRecord {
        pub const SIZE: usize = 8;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| EncodingRecord { data })
        }

        #[inline(always)]
        pub fn platform_id(&self) -> u16 {
            u16::from_be_bytes([self.data[0], self.data[1]])
        }

        #[inline(always)]
        pub fn encoding_id(&self) -> u16 {
            u16::from_be_bytes([self.data[2], self.data[3]])
        }

        #[inline(always)]
        pub fn offset(&self) -> Offset32 {
            Offset32(u32::from_be_bytes([
                self.data[4],
                self.data[5],
                self.data[6],
                self.data[7],
            ]))
        }
    }

    impl FromData for EncodingRecord {
        const SIZE: usize = EncodingRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct SubHeaderRecord {
        data: [u8; 8],
    }

    impl SubHeaderRecord {
        pub const SIZE: usize = 8;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| SubHeaderRecord { data })
        }

        #[inline(always)]
        pub fn first_code(&self) -> u16 {
            u16::from_be_bytes([self.data[0], self.data[1]])
        }

        #[inline(always)]
        pub fn entry_count(&self) -> u16 {
            u16::from_be_bytes([self.data[2], self.data[3]])
        }

        #[inline(always)]
        pub fn id_delta(&self) -> i16 {
            i16::from_be_bytes([self.data[4], self.data[5]])
        }

        #[inline(always)]
        pub fn id_range_offset(&self) -> u16 {
            u16::from_be_bytes([self.data[6], self.data[7]])
        }
    }

    impl FromData for SubHeaderRecord {
        const SIZE: usize = SubHeaderRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct SequentialMapGroup {
        data: [u8; 12],
    }

    impl SequentialMapGroup {
        pub const SIZE: usize = 12;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| SequentialMapGroup { data })
        }

        #[inline(always)]
        pub fn start_char_code(&self) -> u32 {
            u32::from_be_bytes([self.data[0], self.data[1], self.data[2], self.data[3]])
        }

        #[inline(always)]
        pub fn end_char_code(&self) -> u32 {
            u32::from_be_bytes([self.data[4], self.data[5], self.data[6], self.data[7]])
        }

        #[inline(always)]
        pub fn start_glyph_id(&self) -> u32 {
            u32::from_be_bytes([self.data[8], self.data[9], self.data[10], self.data[11]])
        }
    }

    impl FromData for SequentialMapGroup {
        const SIZE: usize = SequentialMapGroup::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct UnicodeRangeRecord {
        data: [u8; 4],
    }

    impl UnicodeRangeRecord {
        pub const SIZE: usize = 4;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| UnicodeRangeRecord { data })
        }

        #[inline(always)]
        pub fn start_unicode_value(&self) -> u32 {
            u32::from_be_bytes([0, self.data[0], self.data[1], self.data[2]])
        }

        #[inline(always)]
        pub fn additional_count(&self) -> u8 {
            self.data[3]
        }
    }

    impl FromData for UnicodeRangeRecord {
        const SIZE: usize = UnicodeRangeRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct UVSMappingRecord {
        data: [u8; 5],
    }

    impl UVSMappingRecord {
        pub const SIZE: usize = 5;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| UVSMappingRecord { data })
        }

        #[inline(always)]
        pub fn unicode_value(&self) -> u32 {
            u32::from_be_bytes([0, self.data[0], self.data[1], self.data[2]])
        }

        #[inline(always)]
        pub fn glyph_id(&self) -> GlyphId {
            GlyphId(u16::from_be_bytes([self.data[3], self.data[4]]))
        }
    }

    impl FromData for UVSMappingRecord {
        const SIZE: usize = UVSMappingRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct VariationSelectorRecord {
        data: [u8; 11],
    }

    impl VariationSelectorRecord {
        pub const SIZE: usize = 11;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| VariationSelectorRecord { data })
        }

        #[inline(always)]
        pub fn var_selector(&self) -> u32 {
            u32::from_be_bytes([0, self.data[0], self.data[1], self.data[2]])
        }

        #[inline(always)]
        pub fn default_uvs_offset(&self) -> Option<Offset32> {
            let n = u32::from_be_bytes([self.data[3], self.data[4], self.data[5], self.data[6]]);
            if n != 0 {
                Some(Offset32(n))
            } else {
                None
            }
        }

        #[inline(always)]
        pub fn non_default_uvs_offset(&self) -> Option<Offset32> {
            let n = u32::from_be_bytes([self.data[7], self.data[8], self.data[9], self.data[10]]);
            if n != 0 {
                Some(Offset32(n))
            } else {
                None
            }
        }
    }

    impl FromData for VariationSelectorRecord {
        const SIZE: usize = VariationSelectorRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod os_2 {
    pub const US_WEIGHT_CLASS_OFFSET: usize = 4;
    pub const US_WIDTH_CLASS_OFFSET: usize = 6;
    pub const Y_SUBSCRIPT_X_SIZE_OFFSET: usize = 10;
    pub const Y_SUPERSCRIPT_X_SIZE_OFFSET: usize = 18;
    pub const Y_STRIKEOUT_SIZE_OFFSET: usize = 26;
    pub const Y_STRIKEOUT_POSITION_OFFSET: usize = 28;
    pub const FS_SELECTION_OFFSET: usize = 62;
    pub const S_TYPO_ASCENDER_OFFSET: usize = 68;
    pub const S_TYPO_DESCENDER_OFFSET: usize = 70;
    pub const S_TYPO_LINE_GAP_OFFSET: usize = 72;
    pub const SX_HEIGHT_OFFSET: usize = 86;
}

pub mod name {
    use crate::parser::FromData;

    #[derive(Clone, Copy)]
    pub struct NameRecord {
        data: [u8; 12],
    }

    impl NameRecord {
        pub const SIZE: usize = 12;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| NameRecord { data })
        }

        #[inline(always)]
        pub fn platform_id(&self) -> u16 {
            u16::from_be_bytes([self.data[0], self.data[1]])
        }

        #[inline(always)]
        pub fn encoding_id(&self) -> u16 {
            u16::from_be_bytes([self.data[2], self.data[3]])
        }

        #[inline(always)]
        pub fn language_id(&self) -> u16 {
            u16::from_be_bytes([self.data[4], self.data[5]])
        }

        #[inline(always)]
        pub fn name_id(&self) -> u16 {
            u16::from_be_bytes([self.data[6], self.data[7]])
        }

        #[inline(always)]
        pub fn length(&self) -> u16 {
            u16::from_be_bytes([self.data[8], self.data[9]])
        }

        #[inline(always)]
        pub fn offset(&self) -> u16 {
            u16::from_be_bytes([self.data[10], self.data[11]])
        }
    }

    impl FromData for NameRecord {
        const SIZE: usize = NameRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod kern {
    use crate::parser::FromData;

    #[derive(Clone, Copy)]
    pub struct Coverage {
        data: [u8; 2],
    }

    impl Coverage {
        pub const SIZE: usize = 2;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| Coverage { data })
        }

        #[inline(always)]
        pub fn coverage(&self) -> u8 {
            self.data[0]
        }

        #[inline(always)]
        pub fn format(&self) -> u8 {
            self.data[1]
        }
    }

    impl FromData for Coverage {
        const SIZE: usize = Coverage::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct KerningRecord {
        data: [u8; 6],
    }

    impl KerningRecord {
        pub const SIZE: usize = 6;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| KerningRecord { data })
        }

        #[inline(always)]
        pub fn pair(&self) -> u32 {
            u32::from_be_bytes([self.data[0], self.data[1], self.data[2], self.data[3]])
        }

        #[inline(always)]
        pub fn value(&self) -> i16 {
            i16::from_be_bytes([self.data[4], self.data[5]])
        }
    }

    impl FromData for KerningRecord {
        const SIZE: usize = KerningRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod gdef {
    use crate::parser::FromData;
    use crate::GlyphId;
    use core::ops::RangeInclusive;

    #[derive(Clone, Copy)]
    pub struct ClassRangeRecord {
        data: [u8; 6],
    }

    impl ClassRangeRecord {
        pub const SIZE: usize = 6;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| ClassRangeRecord { data })
        }

        #[inline(always)]
        pub fn range(&self) -> RangeInclusive<GlyphId> {
            GlyphId(u16::from_be_bytes([self.data[0], self.data[1]]))
                ..=GlyphId(u16::from_be_bytes([self.data[2], self.data[3]]))
        }

        #[inline(always)]
        pub fn class(&self) -> u16 {
            u16::from_be_bytes([self.data[4], self.data[5]])
        }
    }

    impl FromData for ClassRangeRecord {
        const SIZE: usize = ClassRangeRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }

    #[derive(Clone, Copy)]
    pub struct RangeRecord {
        data: [u8; 6],
    }

    impl RangeRecord {
        pub const SIZE: usize = 6;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| RangeRecord { data })
        }

        #[inline(always)]
        pub fn range(&self) -> RangeInclusive<GlyphId> {
            GlyphId(u16::from_be_bytes([self.data[0], self.data[1]]))
                ..=GlyphId(u16::from_be_bytes([self.data[2], self.data[3]]))
        }

        #[inline(always)]
        pub fn start_coverage_index(&self) -> u16 {
            u16::from_be_bytes([self.data[4], self.data[5]])
        }
    }

    impl FromData for RangeRecord {
        const SIZE: usize = RangeRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod avar {
    use crate::parser::FromData;

    #[derive(Clone, Copy)]
    pub struct AxisValueMapRecord {
        data: [u8; 4],
    }

    impl AxisValueMapRecord {
        pub const SIZE: usize = 4;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| AxisValueMapRecord { data })
        }

        #[inline(always)]
        pub fn from_coordinate(&self) -> i16 {
            i16::from_be_bytes([self.data[0], self.data[1]])
        }

        #[inline(always)]
        pub fn to_coordinate(&self) -> i16 {
            i16::from_be_bytes([self.data[2], self.data[3]])
        }
    }

    impl FromData for AxisValueMapRecord {
        const SIZE: usize = AxisValueMapRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod fvar {
    use crate::parser::FromData;
    use crate::Tag;

    #[derive(Clone, Copy)]
    pub struct VariationAxisRecord {
        data: [u8; 20],
    }

    impl VariationAxisRecord {
        pub const SIZE: usize = 20;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| VariationAxisRecord { data })
        }

        #[inline(always)]
        pub fn axis_tag(&self) -> Tag {
            Tag(u32::from_be_bytes([
                self.data[0],
                self.data[1],
                self.data[2],
                self.data[3],
            ]))
        }

        #[inline(always)]
        pub fn min_value(&self) -> f32 {
            i32::from_be_bytes([self.data[4], self.data[5], self.data[6], self.data[7]]) as f32
                / 65536.0
        }

        #[inline(always)]
        pub fn def_value(&self) -> f32 {
            i32::from_be_bytes([self.data[8], self.data[9], self.data[10], self.data[11]]) as f32
                / 65536.0
        }

        #[inline(always)]
        pub fn max_value(&self) -> f32 {
            i32::from_be_bytes([self.data[12], self.data[13], self.data[14], self.data[15]]) as f32
                / 65536.0
        }

        #[inline(always)]
        pub fn flags(&self) -> u16 {
            u16::from_be_bytes([self.data[16], self.data[17]])
        }

        #[inline(always)]
        pub fn axis_name_id(&self) -> u16 {
            u16::from_be_bytes([self.data[18], self.data[19]])
        }
    }

    impl FromData for VariationAxisRecord {
        const SIZE: usize = VariationAxisRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod vorg {
    use crate::parser::FromData;
    use crate::GlyphId;

    #[derive(Clone, Copy)]
    pub struct VertOriginYMetrics {
        data: [u8; 4],
    }

    impl VertOriginYMetrics {
        pub const SIZE: usize = 4;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| VertOriginYMetrics { data })
        }

        #[inline(always)]
        pub fn glyph_index(&self) -> GlyphId {
            GlyphId(u16::from_be_bytes([self.data[0], self.data[1]]))
        }

        #[inline(always)]
        pub fn vert_origin_y(&self) -> i16 {
            i16::from_be_bytes([self.data[2], self.data[3]])
        }
    }

    impl FromData for VertOriginYMetrics {
        const SIZE: usize = VertOriginYMetrics::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod mvar {
    use crate::parser::FromData;
    use crate::Tag;

    #[derive(Clone, Copy)]
    pub struct ValueRecord {
        data: [u8; 8],
    }

    impl ValueRecord {
        pub const SIZE: usize = 8;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| ValueRecord { data })
        }

        #[inline(always)]
        pub fn value_tag(&self) -> Tag {
            Tag(u32::from_be_bytes([
                self.data[0],
                self.data[1],
                self.data[2],
                self.data[3],
            ]))
        }

        #[inline(always)]
        pub fn delta_set_outer_index(&self) -> u16 {
            u16::from_be_bytes([self.data[4], self.data[5]])
        }

        #[inline(always)]
        pub fn delta_set_inner_index(&self) -> u16 {
            u16::from_be_bytes([self.data[6], self.data[7]])
        }
    }

    impl FromData for ValueRecord {
        const SIZE: usize = ValueRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod var_store {
    use crate::parser::FromData;

    #[derive(Clone, Copy)]
    pub struct RegionAxisCoordinatesRecord {
        data: [u8; 6],
    }

    impl RegionAxisCoordinatesRecord {
        pub const SIZE: usize = 6;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input
                .try_into()
                .ok()
                .map(|data| RegionAxisCoordinatesRecord { data })
        }

        #[inline(always)]
        pub fn start_coord(&self) -> i16 {
            i16::from_be_bytes([self.data[0], self.data[1]])
        }

        #[inline(always)]
        pub fn peak_coord(&self) -> i16 {
            i16::from_be_bytes([self.data[2], self.data[3]])
        }

        #[inline(always)]
        pub fn end_coord(&self) -> i16 {
            i16::from_be_bytes([self.data[4], self.data[5]])
        }
    }

    impl FromData for RegionAxisCoordinatesRecord {
        const SIZE: usize = RegionAxisCoordinatesRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}

pub mod svg {
    use crate::parser::{FromData, Offset32};
    use crate::GlyphId;

    #[derive(Clone, Copy)]
    pub struct SvgDocumentRecord {
        data: [u8; 12],
    }

    impl SvgDocumentRecord {
        pub const SIZE: usize = 12;

        #[inline(always)]
        pub fn new(input: &[u8]) -> Option<Self> {
            use core::convert::TryInto;
            input.try_into().ok().map(|data| SvgDocumentRecord { data })
        }

        #[inline(always)]
        pub fn start_glyph_id(&self) -> GlyphId {
            GlyphId(u16::from_be_bytes([self.data[0], self.data[1]]))
        }

        #[inline(always)]
        pub fn end_glyph_id(&self) -> GlyphId {
            GlyphId(u16::from_be_bytes([self.data[2], self.data[3]]))
        }

        #[inline(always)]
        pub fn svg_doc_offset(&self) -> Option<Offset32> {
            let n = u32::from_be_bytes([self.data[4], self.data[5], self.data[6], self.data[7]]);
            if n != 0 {
                Some(Offset32(n))
            } else {
                None
            }
        }

        #[inline(always)]
        pub fn svg_doc_length(&self) -> u32 {
            u32::from_be_bytes([self.data[8], self.data[9], self.data[10], self.data[11]])
        }
    }

    impl FromData for SvgDocumentRecord {
        const SIZE: usize = SvgDocumentRecord::SIZE;

        #[inline]
        fn parse(data: &[u8]) -> Option<Self> {
            Self::new(data)
        }
    }
}
